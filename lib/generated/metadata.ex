defmodule Kayrock.Metadata do
  @api :metadata
  @moduledoc "Kayrock-generated module for the Kafka `#{@api}` API
"
  _ = " THIS CODE IS GENERATED BY KAYROCK"

  (
    @vmin 0
    @vmax 9
  )

  defmodule V0.Request do
    @vsn 0
    @api :metadata
    @schema topics: {:array, name: :string}
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct topics: [], correlation_id: nil, client_id: nil
    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      0
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V0.Response.t(), binary})
    def response_deserializer do
      &V0.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [topics: {:array, name: :string}]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V0.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V0.Request) do
    def serialize(%V0.Request{} = struct) do
      try do
        V0.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V0.Request{}) do
      V0.Request.api_vsn()
    end

    def response_deserializer(%V0.Request{}) do
      V0.Request.response_deserializer()
    end
  end

  defmodule V1.Request do
    @vsn 1
    @api :metadata
    @schema topics: {:array, name: :string}
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct topics: [], correlation_id: nil, client_id: nil
    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      1
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V1.Response.t(), binary})
    def response_deserializer do
      &V1.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [topics: {:array, name: :string}]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V1.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V1.Request) do
    def serialize(%V1.Request{} = struct) do
      try do
        V1.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V1.Request{}) do
      V1.Request.api_vsn()
    end

    def response_deserializer(%V1.Request{}) do
      V1.Request.response_deserializer()
    end
  end

  defmodule V2.Request do
    @vsn 2
    @api :metadata
    @schema topics: {:array, name: :string}
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct topics: [], correlation_id: nil, client_id: nil
    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      2
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V2.Response.t(), binary})
    def response_deserializer do
      &V2.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [topics: {:array, name: :string}]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V2.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V2.Request) do
    def serialize(%V2.Request{} = struct) do
      try do
        V2.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V2.Request{}) do
      V2.Request.api_vsn()
    end

    def response_deserializer(%V2.Request{}) do
      V2.Request.response_deserializer()
    end
  end

  defmodule V3.Request do
    @vsn 3
    @api :metadata
    @schema topics: {:array, name: :string}
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct topics: [], correlation_id: nil, client_id: nil
    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      3
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V3.Response.t(), binary})
    def response_deserializer do
      &V3.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [topics: {:array, name: :string}]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V3.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V3.Request) do
    def serialize(%V3.Request{} = struct) do
      try do
        V3.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V3.Request{}) do
      V3.Request.api_vsn()
    end

    def response_deserializer(%V3.Request{}) do
      V3.Request.response_deserializer()
    end
  end

  defmodule V4.Request do
    @vsn 4
    @api :metadata
    @schema topics: {:array, name: :string}, allow_auto_topic_creation: :boolean
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct topics: [], allow_auto_topic_creation: nil, correlation_id: nil, client_id: nil
    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            allow_auto_topic_creation: nil | integer(),
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      4
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V4.Response.t(), binary})
    def response_deserializer do
      &V4.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [topics: {:array, name: :string}, allow_auto_topic_creation: :boolean]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V4.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end,
          serialize(:boolean, Map.fetch!(struct, :allow_auto_topic_creation))
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V4.Request) do
    def serialize(%V4.Request{} = struct) do
      try do
        V4.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V4.Request{}) do
      V4.Request.api_vsn()
    end

    def response_deserializer(%V4.Request{}) do
      V4.Request.response_deserializer()
    end
  end

  defmodule V5.Request do
    @vsn 5
    @api :metadata
    @schema topics: {:array, name: :string}, allow_auto_topic_creation: :boolean
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct topics: [], allow_auto_topic_creation: nil, correlation_id: nil, client_id: nil
    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            allow_auto_topic_creation: nil | integer(),
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      5
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V5.Response.t(), binary})
    def response_deserializer do
      &V5.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [topics: {:array, name: :string}, allow_auto_topic_creation: :boolean]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V5.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end,
          serialize(:boolean, Map.fetch!(struct, :allow_auto_topic_creation))
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V5.Request) do
    def serialize(%V5.Request{} = struct) do
      try do
        V5.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V5.Request{}) do
      V5.Request.api_vsn()
    end

    def response_deserializer(%V5.Request{}) do
      V5.Request.response_deserializer()
    end
  end

  defmodule V6.Request do
    @vsn 6
    @api :metadata
    @schema topics: {:array, name: :string}, allow_auto_topic_creation: :boolean
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct topics: [], allow_auto_topic_creation: nil, correlation_id: nil, client_id: nil
    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            allow_auto_topic_creation: nil | integer(),
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      6
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V6.Response.t(), binary})
    def response_deserializer do
      &V6.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [topics: {:array, name: :string}, allow_auto_topic_creation: :boolean]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V6.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end,
          serialize(:boolean, Map.fetch!(struct, :allow_auto_topic_creation))
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V6.Request) do
    def serialize(%V6.Request{} = struct) do
      try do
        V6.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V6.Request{}) do
      V6.Request.api_vsn()
    end

    def response_deserializer(%V6.Request{}) do
      V6.Request.response_deserializer()
    end
  end

  defmodule V7.Request do
    @vsn 7
    @api :metadata
    @schema topics: {:array, name: :string}, allow_auto_topic_creation: :boolean
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct topics: [], allow_auto_topic_creation: nil, correlation_id: nil, client_id: nil
    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            allow_auto_topic_creation: nil | integer(),
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      7
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V7.Response.t(), binary})
    def response_deserializer do
      &V7.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [topics: {:array, name: :string}, allow_auto_topic_creation: :boolean]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V7.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end,
          serialize(:boolean, Map.fetch!(struct, :allow_auto_topic_creation))
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V7.Request) do
    def serialize(%V7.Request{} = struct) do
      try do
        V7.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V7.Request{}) do
      V7.Request.api_vsn()
    end

    def response_deserializer(%V7.Request{}) do
      V7.Request.response_deserializer()
    end
  end

  defmodule V8.Request do
    @vsn 8
    @api :metadata
    @schema topics: {:array, name: :string},
            allow_auto_topic_creation: :boolean,
            include_cluster_authorized_operations: :boolean,
            include_topic_authorized_operations: :boolean
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct topics: [],
              allow_auto_topic_creation: nil,
              include_cluster_authorized_operations: nil,
              include_topic_authorized_operations: nil,
              correlation_id: nil,
              client_id: nil

    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics: [%{name: nil | binary()}],
            allow_auto_topic_creation: nil | integer(),
            include_cluster_authorized_operations: nil | integer(),
            include_topic_authorized_operations: nil | integer(),
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      8
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V8.Response.t(), binary})
    def response_deserializer do
      &V8.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        topics: {:array, name: :string},
        allow_auto_topic_creation: :boolean,
        include_cluster_authorized_operations: :boolean,
        include_topic_authorized_operations: :boolean
      ]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V8.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              <<-1::32-signed>>

            [] ->
              <<0::32-signed>>

            vals when is_list(vals) ->
              [
                <<length(vals)::32-signed>>,
                for v <- vals do
                  [serialize(:string, Map.fetch!(v, :name))]
                end
              ]
          end,
          serialize(:boolean, Map.fetch!(struct, :allow_auto_topic_creation)),
          serialize(:boolean, Map.fetch!(struct, :include_cluster_authorized_operations)),
          serialize(:boolean, Map.fetch!(struct, :include_topic_authorized_operations))
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V8.Request) do
    def serialize(%V8.Request{} = struct) do
      try do
        V8.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V8.Request{}) do
      V8.Request.api_vsn()
    end

    def response_deserializer(%V8.Request{}) do
      V8.Request.response_deserializer()
    end
  end

  defmodule V9.Request do
    @vsn 9
    @api :metadata
    @schema topics: {:compact_array, name: :compact_string, tagged_fields: :tagged_fields},
            allow_auto_topic_creation: :boolean,
            include_cluster_authorized_operations: :boolean,
            include_topic_authorized_operations: :boolean,
            tagged_fields: :tagged_fields
    @moduledoc "Kayrock-generated request struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct topics: [],
              allow_auto_topic_creation: nil,
              include_cluster_authorized_operations: nil,
              include_topic_authorized_operations: nil,
              tagged_fields: [],
              correlation_id: nil,
              client_id: nil

    import Elixir.Kayrock.Serialize
    @typedoc "Request struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            topics:
              nil | [%{name: nil | binary(), tagged_fields: [{non_neg_integer(), binary()}]}],
            allow_auto_topic_creation: nil | integer(),
            include_cluster_authorized_operations: nil | integer(),
            include_topic_authorized_operations: nil | integer(),
            tagged_fields: [{non_neg_integer(), binary()}],
            correlation_id: nil | integer(),
            client_id: nil | binary()
          }
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      9
    end

    @doc "Returns a function that can be used to deserialize the wire response from the\nbroker for this message type\n"
    @spec response_deserializer :: (binary -> {V9.Response.t(), binary})
    def response_deserializer do
      &V9.Response.deserialize/1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        topics: {:compact_array, name: :compact_string, tagged_fields: :tagged_fields},
        allow_auto_topic_creation: :boolean,
        include_cluster_authorized_operations: :boolean,
        include_topic_authorized_operations: :boolean,
        tagged_fields: :tagged_fields
      ]
    end

    @doc "Serialize a message to binary data for transfer to a Kafka broker"
    @spec serialize(t()) :: iodata
    def serialize(%V9.Request{} = struct) do
      [
        <<api_key()::16, api_vsn()::16, struct.correlation_id::32,
          byte_size(struct.client_id)::16, struct.client_id::binary>>,
        <<0>>,
        [
          case Map.fetch!(struct, :topics) do
            nil ->
              Kayrock.Serialize.encode_unsigned_varint(0)

            [] ->
              Kayrock.Serialize.encode_unsigned_varint(1)

            vals when is_list(vals) ->
              [
                Kayrock.Serialize.encode_unsigned_varint(length(vals) + 1),
                for v <- vals do
                  [
                    serialize(:compact_string, Map.fetch!(v, :name)),
                    serialize_tagged_fields(Map.get(v, :tagged_fields, []))
                  ]
                end
              ]
          end,
          serialize(:boolean, Map.fetch!(struct, :allow_auto_topic_creation)),
          serialize(:boolean, Map.fetch!(struct, :include_cluster_authorized_operations)),
          serialize(:boolean, Map.fetch!(struct, :include_topic_authorized_operations)),
          serialize_tagged_fields(Map.get(struct, :tagged_fields, []))
        ]
      ]
    end
  end

  defimpl(Elixir.Kayrock.Request, for: V9.Request) do
    def serialize(%V9.Request{} = struct) do
      try do
        V9.Request.serialize(struct)
      rescue
        e -> reraise Kayrock.InvalidRequestError, {e, struct}, __STACKTRACE__
      end
    end

    def api_vsn(%V9.Request{}) do
      V9.Request.api_vsn()
    end

    def response_deserializer(%V9.Request{}) do
      V9.Request.response_deserializer()
    end
  end

  (
    @doc "Returns a request struct for this API with the given version"
    @spec get_request_struct(integer) :: request_t
  )

  def get_request_struct(0) do
    %V0.Request{}
  end

  def get_request_struct(1) do
    %V1.Request{}
  end

  def get_request_struct(2) do
    %V2.Request{}
  end

  def get_request_struct(3) do
    %V3.Request{}
  end

  def get_request_struct(4) do
    %V4.Request{}
  end

  def get_request_struct(5) do
    %V5.Request{}
  end

  def get_request_struct(6) do
    %V6.Request{}
  end

  def get_request_struct(7) do
    %V7.Request{}
  end

  def get_request_struct(8) do
    %V8.Request{}
  end

  def get_request_struct(9) do
    %V9.Request{}
  end

  defmodule V0.Response do
    @vsn 0
    @api :metadata
    @schema brokers: {:array, node_id: :int32, host: :string, port: :int32},
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32}}}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct brokers: [], topics: [], correlation_id: nil
    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            brokers: [%{node_id: nil | integer(), host: nil | binary(), port: nil | integer()}],
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      0
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        brokers: {:array, node_id: :int32, host: :string, port: :int32},
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32}}}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data
      deserialize_field(:root, :brokers, %__MODULE__{correlation_id: correlation_id}, rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, nil, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :topics, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partitions, nil, Map.put(acc, :isr_nodes, Enum.reverse(val)), rest)
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:topics, nil, Map.put(acc, :partitions, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topics, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V1.Response do
    @vsn 1
    @api :metadata
    @schema brokers:
              {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
            controller_id: :int32,
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               is_internal: :boolean,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32}}}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct brokers: [], controller_id: nil, topics: [], correlation_id: nil
    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            controller_id: nil | integer(),
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                is_internal: nil | integer(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      1
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        brokers: {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
        controller_id: :int32,
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           is_internal: :boolean,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32}}}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data
      deserialize_field(:root, :brokers, %__MODULE__{correlation_id: correlation_id}, rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :controller_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partitions, nil, Map.put(acc, :isr_nodes, Enum.reverse(val)), rest)
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:topics, nil, Map.put(acc, :partitions, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topics, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V2.Response do
    @vsn 2
    @api :metadata
    @schema brokers:
              {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               is_internal: :boolean,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32}}}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"
    defstruct brokers: [], cluster_id: nil, controller_id: nil, topics: [], correlation_id: nil
    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                is_internal: nil | integer(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      2
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        brokers: {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           is_internal: :boolean,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32}}}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data
      deserialize_field(:root, :brokers, %__MODULE__{correlation_id: correlation_id}, rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :cluster_id, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partitions, nil, Map.put(acc, :isr_nodes, Enum.reverse(val)), rest)
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:topics, nil, Map.put(acc, :partitions, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topics, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V3.Response do
    @vsn 3
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               is_internal: :boolean,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32}}}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct throttle_time_ms: nil,
              brokers: [],
              cluster_id: nil,
              controller_id: nil,
              topics: [],
              correlation_id: nil

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                is_internal: nil | integer(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      3
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        throttle_time_ms: :int32,
        brokers: {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           is_internal: :boolean,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32}}}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp deserialize_field(:root, :throttle_time_ms, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :cluster_id, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partitions, nil, Map.put(acc, :isr_nodes, Enum.reverse(val)), rest)
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:topics, nil, Map.put(acc, :partitions, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topics, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V4.Response do
    @vsn 4
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               is_internal: :boolean,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32}}}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct throttle_time_ms: nil,
              brokers: [],
              cluster_id: nil,
              controller_id: nil,
              topics: [],
              correlation_id: nil

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                is_internal: nil | integer(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      4
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        throttle_time_ms: :int32,
        brokers: {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           is_internal: :boolean,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32}}}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp deserialize_field(:root, :throttle_time_ms, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :cluster_id, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)
      deserialize_field(:partitions, nil, Map.put(acc, :isr_nodes, Enum.reverse(val)), rest)
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:topics, nil, Map.put(acc, :partitions, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topics, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V5.Response do
    @vsn 5
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               is_internal: :boolean,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32},
                  offline_replicas: {:array, :int32}}}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct throttle_time_ms: nil,
              brokers: [],
              cluster_id: nil,
              controller_id: nil,
              topics: [],
              correlation_id: nil

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                is_internal: nil | integer(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()],
                    offline_replicas: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      5
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        throttle_time_ms: :int32,
        brokers: {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           is_internal: :boolean,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32},
              offline_replicas: {:array, :int32}}}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp deserialize_field(:root, :throttle_time_ms, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :cluster_id, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :offline_replicas,
        Map.put(acc, :isr_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :offline_replicas, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        nil,
        Map.put(acc, :offline_replicas, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:topics, nil, Map.put(acc, :partitions, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topics, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V6.Response do
    @vsn 6
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               is_internal: :boolean,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32},
                  offline_replicas: {:array, :int32}}}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct throttle_time_ms: nil,
              brokers: [],
              cluster_id: nil,
              controller_id: nil,
              topics: [],
              correlation_id: nil

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                is_internal: nil | integer(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()],
                    offline_replicas: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      6
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        throttle_time_ms: :int32,
        brokers: {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           is_internal: :boolean,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32},
              offline_replicas: {:array, :int32}}}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp deserialize_field(:root, :throttle_time_ms, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :cluster_id, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :offline_replicas,
        Map.put(acc, :isr_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :offline_replicas, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        nil,
        Map.put(acc, :offline_replicas, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:topics, nil, Map.put(acc, :partitions, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topics, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V7.Response do
    @vsn 7
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               is_internal: :boolean,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  leader_epoch: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32},
                  offline_replicas: {:array, :int32}}}
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct throttle_time_ms: nil,
              brokers: [],
              cluster_id: nil,
              controller_id: nil,
              topics: [],
              correlation_id: nil

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                is_internal: nil | integer(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    leader_epoch: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()],
                    offline_replicas: [nil | integer()]
                  }
                ]
              }
            ],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      7
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        throttle_time_ms: :int32,
        brokers: {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           is_internal: :boolean,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              leader_epoch: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32},
              offline_replicas: {:array, :int32}}}
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp deserialize_field(:root, :throttle_time_ms, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :cluster_id, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_epoch, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :leader_epoch, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_epoch, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :offline_replicas,
        Map.put(acc, :isr_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :offline_replicas, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        nil,
        Map.put(acc, :offline_replicas, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:topics, nil, Map.put(acc, :partitions, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, nil, Map.put(acc, :topics, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V8.Response do
    @vsn 8
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
            cluster_id: :nullable_string,
            controller_id: :int32,
            topics:
              {:array,
               error_code: :int16,
               name: :string,
               is_internal: :boolean,
               partitions:
                 {:array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  leader_epoch: :int32,
                  replica_nodes: {:array, :int32},
                  isr_nodes: {:array, :int32},
                  offline_replicas: {:array, :int32}},
               topic_authorized_operations: :int32},
            cluster_authorized_operations: :int32
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct throttle_time_ms: nil,
              brokers: [],
              cluster_id: nil,
              controller_id: nil,
              topics: [],
              cluster_authorized_operations: nil,
              correlation_id: nil

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers: [
              %{
                node_id: nil | integer(),
                host: nil | binary(),
                port: nil | integer(),
                rack: nil | binary()
              }
            ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topics: [
              %{
                error_code: nil | integer(),
                name: nil | binary(),
                is_internal: nil | integer(),
                partitions: [
                  %{
                    error_code: nil | integer(),
                    partition_index: nil | integer(),
                    leader_id: nil | integer(),
                    leader_epoch: nil | integer(),
                    replica_nodes: [nil | integer()],
                    isr_nodes: [nil | integer()],
                    offline_replicas: [nil | integer()]
                  }
                ],
                topic_authorized_operations: nil | integer()
              }
            ],
            cluster_authorized_operations: nil | integer(),
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      8
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        throttle_time_ms: :int32,
        brokers: {:array, node_id: :int32, host: :string, port: :int32, rack: :nullable_string},
        cluster_id: :nullable_string,
        controller_id: :int32,
        topics:
          {:array,
           error_code: :int16,
           name: :string,
           is_internal: :boolean,
           partitions:
             {:array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              leader_epoch: :int32,
              replica_nodes: {:array, :int32},
              isr_nodes: {:array, :int32},
              offline_replicas: {:array, :int32}},
           topic_authorized_operations: :int32},
        cluster_authorized_operations: :int32
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp deserialize_field(:root, :throttle_time_ms, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:brokers, nil, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, Enum.reverse(vals)), rest)
    end

    defp deserialize_field(:root, :cluster_id, acc, data) do
      {val, rest} = deserialize(:nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_epoch, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :leader_epoch, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_epoch, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :isr_nodes,
        Map.put(acc, :replica_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        :offline_replicas,
        Map.put(acc, :isr_nodes, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:partitions, :offline_replicas, acc, data) do
      {val, rest} = deserialize_array(:int32, data)

      deserialize_field(
        :partitions,
        nil,
        Map.put(acc, :offline_replicas, Enum.reverse(val)),
        rest
      )
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :topics,
        :topic_authorized_operations,
        Map.put(acc, :partitions, Enum.reverse(vals)),
        rest
      )
    end

    defp deserialize_field(:topics, :topic_authorized_operations, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:topics, nil, Map.put(acc, :topic_authorized_operations, val), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      <<num_elements::32-signed, rest::binary>> = data

      {vals, rest} =
        if num_elements > 0 do
          Enum.reduce(1..num_elements, {[], rest}, fn _ix, {acc, d} ->
            {val, r} = deserialize_field(:topics, :error_code, %{}, d)
            {[val | acc], r}
          end)
        else
          {[], rest}
        end

      deserialize_field(
        :root,
        :cluster_authorized_operations,
        Map.put(acc, :topics, Enum.reverse(vals)),
        rest
      )
    end

    defp deserialize_field(:root, :cluster_authorized_operations, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, nil, Map.put(acc, :cluster_authorized_operations, val), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  defmodule V9.Response do
    @vsn 9
    @api :metadata
    @schema throttle_time_ms: :int32,
            brokers:
              {:compact_array,
               node_id: :int32,
               host: :compact_string,
               port: :int32,
               rack: :compact_nullable_string,
               tagged_fields: :tagged_fields},
            cluster_id: :compact_nullable_string,
            controller_id: :int32,
            topics:
              {:compact_array,
               error_code: :int16,
               name: :compact_string,
               is_internal: :boolean,
               partitions:
                 {:compact_array,
                  error_code: :int16,
                  partition_index: :int32,
                  leader_id: :int32,
                  leader_epoch: :int32,
                  replica_nodes: {:compact_array, :int32},
                  isr_nodes: {:compact_array, :int32},
                  offline_replicas: {:compact_array, :int32},
                  tagged_fields: :tagged_fields},
               topic_authorized_operations: :int32,
               tagged_fields: :tagged_fields},
            cluster_authorized_operations: :int32,
            tagged_fields: :tagged_fields
    @moduledoc "Kayrock-generated response struct for Kafka `#{@api}` v#{@vsn} API
messages

The schema of this API is
```
#{inspect(@schema, pretty: true)}
```
"
    _ = " THIS CODE IS GENERATED BY KAYROCK"

    defstruct throttle_time_ms: nil,
              brokers: [],
              cluster_id: nil,
              controller_id: nil,
              topics: [],
              cluster_authorized_operations: nil,
              tagged_fields: [],
              correlation_id: nil

    @typedoc "Response struct for the Kafka `#{@api}` API v#{@vsn}
"
    @type t :: %__MODULE__{
            throttle_time_ms: nil | integer(),
            brokers:
              nil
              | [
                  %{
                    node_id: nil | integer(),
                    host: nil | binary(),
                    port: nil | integer(),
                    rack: nil | binary(),
                    tagged_fields: [{non_neg_integer(), binary()}]
                  }
                ],
            cluster_id: nil | binary(),
            controller_id: nil | integer(),
            topics:
              nil
              | [
                  %{
                    error_code: nil | integer(),
                    name: nil | binary(),
                    is_internal: nil | integer(),
                    partitions:
                      nil
                      | [
                          %{
                            error_code: nil | integer(),
                            partition_index: nil | integer(),
                            leader_id: nil | integer(),
                            leader_epoch: nil | integer(),
                            replica_nodes: nil | [nil | integer()],
                            isr_nodes: nil | [nil | integer()],
                            offline_replicas: nil | [nil | integer()],
                            tagged_fields: [{non_neg_integer(), binary()}]
                          }
                        ],
                    topic_authorized_operations: nil | integer(),
                    tagged_fields: [{non_neg_integer(), binary()}]
                  }
                ],
            cluster_authorized_operations: nil | integer(),
            tagged_fields: [{non_neg_integer(), binary()}],
            correlation_id: integer()
          }
    import Elixir.Kayrock.Deserialize
    @doc "Returns the Kafka API key for this API"
    @spec api_key :: integer
    def api_key do
      Kayrock.KafkaSchemaMetadata.api_key(:metadata)
    end

    @doc "Returns the API version (#{@vsn}) implemented by this module"
    @spec api_vsn :: integer
    def api_vsn do
      9
    end

    @doc "Returns the schema of this message\n\nSee [above](#).\n"
    @spec schema :: term
    def schema do
      [
        throttle_time_ms: :int32,
        brokers:
          {:compact_array,
           node_id: :int32,
           host: :compact_string,
           port: :int32,
           rack: :compact_nullable_string,
           tagged_fields: :tagged_fields},
        cluster_id: :compact_nullable_string,
        controller_id: :int32,
        topics:
          {:compact_array,
           error_code: :int16,
           name: :compact_string,
           is_internal: :boolean,
           partitions:
             {:compact_array,
              error_code: :int16,
              partition_index: :int32,
              leader_id: :int32,
              leader_epoch: :int32,
              replica_nodes: {:compact_array, :int32},
              isr_nodes: {:compact_array, :int32},
              offline_replicas: {:compact_array, :int32},
              tagged_fields: :tagged_fields},
           topic_authorized_operations: :int32,
           tagged_fields: :tagged_fields},
        cluster_authorized_operations: :int32,
        tagged_fields: :tagged_fields
      ]
    end

    @doc "Deserialize data for this version of this API\n"
    @spec deserialize(binary) :: {t(), binary}
    def deserialize(data) do
      <<correlation_id::32-signed, rest::binary>> = data
      {_tagged_fields, rest} = deserialize_tagged_fields(rest)

      deserialize_field(
        :root,
        :throttle_time_ms,
        %__MODULE__{correlation_id: correlation_id},
        rest
      )
    end

    defp deserialize_field(:root, :throttle_time_ms, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :brokers, Map.put(acc, :throttle_time_ms, val), rest)
    end

    defp deserialize_field(:brokers, :node_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :host, Map.put(acc, :node_id, val), rest)
    end

    defp deserialize_field(:brokers, :host, acc, data) do
      {val, rest} = deserialize(:compact_string, data)
      deserialize_field(:brokers, :port, Map.put(acc, :host, val), rest)
    end

    defp deserialize_field(:brokers, :port, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:brokers, :rack, Map.put(acc, :port, val), rest)
    end

    defp deserialize_field(:brokers, :rack, acc, data) do
      {val, rest} = deserialize(:compact_nullable_string, data)
      deserialize_field(:brokers, :tagged_fields, Map.put(acc, :rack, val), rest)
    end

    defp deserialize_field(:brokers, :tagged_fields, acc, data) do
      {val, rest} = Kayrock.Deserialize.deserialize_tagged_fields(data)
      deserialize_field(:brokers, nil, Map.put(acc, :tagged_fields, val), rest)
    end

    defp deserialize_field(:root, :brokers, acc, data) do
      {len_plus_one, rest} = Kayrock.Deserialize.decode_unsigned_varint(data)

      {vals, rest} =
        case len_plus_one do
          0 ->
            {nil, rest}

          1 ->
            {[], rest}

          _ ->
            Enum.reduce(1..(len_plus_one - 1), {[], rest}, fn _ix, {acc_inner, d} ->
              {val, r} = deserialize_field(:brokers, :node_id, %{}, d)
              {[val | acc_inner], r}
            end)
        end

      final_vals =
        if is_nil(vals) do
          nil
        else
          Enum.reverse(vals)
        end

      deserialize_field(:root, :cluster_id, Map.put(acc, :brokers, final_vals), rest)
    end

    defp deserialize_field(:root, :cluster_id, acc, data) do
      {val, rest} = deserialize(:compact_nullable_string, data)
      deserialize_field(:root, :controller_id, Map.put(acc, :cluster_id, val), rest)
    end

    defp deserialize_field(:root, :controller_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:root, :topics, Map.put(acc, :controller_id, val), rest)
    end

    defp deserialize_field(:topics, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:topics, :name, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:topics, :name, acc, data) do
      {val, rest} = deserialize(:compact_string, data)
      deserialize_field(:topics, :is_internal, Map.put(acc, :name, val), rest)
    end

    defp deserialize_field(:topics, :is_internal, acc, data) do
      {val, rest} = deserialize(:boolean, data)
      deserialize_field(:topics, :partitions, Map.put(acc, :is_internal, val), rest)
    end

    defp deserialize_field(:partitions, :error_code, acc, data) do
      {val, rest} = deserialize(:int16, data)
      deserialize_field(:partitions, :partition_index, Map.put(acc, :error_code, val), rest)
    end

    defp deserialize_field(:partitions, :partition_index, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_id, Map.put(acc, :partition_index, val), rest)
    end

    defp deserialize_field(:partitions, :leader_id, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :leader_epoch, Map.put(acc, :leader_id, val), rest)
    end

    defp deserialize_field(:partitions, :leader_epoch, acc, data) do
      {val, rest} = deserialize(:int32, data)
      deserialize_field(:partitions, :replica_nodes, Map.put(acc, :leader_epoch, val), rest)
    end

    defp deserialize_field(:partitions, :replica_nodes, acc, data) do
      {val, rest} = Kayrock.Deserialize.deserialize_compact_array(:int32, data)

      vals =
        if is_nil(val) do
          nil
        else
          Enum.reverse(val)
        end

      deserialize_field(:partitions, :isr_nodes, Map.put(acc, :replica_nodes, vals), rest)
    end

    defp deserialize_field(:partitions, :isr_nodes, acc, data) do
      {val, rest} = Kayrock.Deserialize.deserialize_compact_array(:int32, data)

      vals =
        if is_nil(val) do
          nil
        else
          Enum.reverse(val)
        end

      deserialize_field(:partitions, :offline_replicas, Map.put(acc, :isr_nodes, vals), rest)
    end

    defp deserialize_field(:partitions, :offline_replicas, acc, data) do
      {val, rest} = Kayrock.Deserialize.deserialize_compact_array(:int32, data)

      vals =
        if is_nil(val) do
          nil
        else
          Enum.reverse(val)
        end

      deserialize_field(:partitions, :tagged_fields, Map.put(acc, :offline_replicas, vals), rest)
    end

    defp deserialize_field(:partitions, :tagged_fields, acc, data) do
      {val, rest} = Kayrock.Deserialize.deserialize_tagged_fields(data)
      deserialize_field(:partitions, nil, Map.put(acc, :tagged_fields, val), rest)
    end

    defp deserialize_field(:topics, :partitions, acc, data) do
      {len_plus_one, rest} = Kayrock.Deserialize.decode_unsigned_varint(data)

      {vals, rest} =
        case len_plus_one do
          0 ->
            {nil, rest}

          1 ->
            {[], rest}

          _ ->
            Enum.reduce(1..(len_plus_one - 1), {[], rest}, fn _ix, {acc_inner, d} ->
              {val, r} = deserialize_field(:partitions, :error_code, %{}, d)
              {[val | acc_inner], r}
            end)
        end

      final_vals =
        if is_nil(vals) do
          nil
        else
          Enum.reverse(vals)
        end

      deserialize_field(
        :topics,
        :topic_authorized_operations,
        Map.put(acc, :partitions, final_vals),
        rest
      )
    end

    defp deserialize_field(:topics, :topic_authorized_operations, acc, data) do
      {val, rest} = deserialize(:int32, data)

      deserialize_field(
        :topics,
        :tagged_fields,
        Map.put(acc, :topic_authorized_operations, val),
        rest
      )
    end

    defp deserialize_field(:topics, :tagged_fields, acc, data) do
      {val, rest} = Kayrock.Deserialize.deserialize_tagged_fields(data)
      deserialize_field(:topics, nil, Map.put(acc, :tagged_fields, val), rest)
    end

    defp deserialize_field(:root, :topics, acc, data) do
      {len_plus_one, rest} = Kayrock.Deserialize.decode_unsigned_varint(data)

      {vals, rest} =
        case len_plus_one do
          0 ->
            {nil, rest}

          1 ->
            {[], rest}

          _ ->
            Enum.reduce(1..(len_plus_one - 1), {[], rest}, fn _ix, {acc_inner, d} ->
              {val, r} = deserialize_field(:topics, :error_code, %{}, d)
              {[val | acc_inner], r}
            end)
        end

      final_vals =
        if is_nil(vals) do
          nil
        else
          Enum.reverse(vals)
        end

      deserialize_field(
        :root,
        :cluster_authorized_operations,
        Map.put(acc, :topics, final_vals),
        rest
      )
    end

    defp deserialize_field(:root, :cluster_authorized_operations, acc, data) do
      {val, rest} = deserialize(:int32, data)

      deserialize_field(
        :root,
        :tagged_fields,
        Map.put(acc, :cluster_authorized_operations, val),
        rest
      )
    end

    defp deserialize_field(:root, :tagged_fields, acc, data) do
      {val, rest} = Kayrock.Deserialize.deserialize_tagged_fields(data)
      deserialize_field(:root, nil, Map.put(acc, :tagged_fields, val), rest)
    end

    defp deserialize_field(_, nil, acc, rest) do
      {acc, rest}
    end
  end

  (
    @doc "Deserializes raw wire data for this API with the given version"
    @spec deserialize(integer, binary) :: {response_t, binary}
  )

  def deserialize(0, data) do
    V0.Response.deserialize(data)
  end

  def deserialize(1, data) do
    V1.Response.deserialize(data)
  end

  def deserialize(2, data) do
    V2.Response.deserialize(data)
  end

  def deserialize(3, data) do
    V3.Response.deserialize(data)
  end

  def deserialize(4, data) do
    V4.Response.deserialize(data)
  end

  def deserialize(5, data) do
    V5.Response.deserialize(data)
  end

  def deserialize(6, data) do
    V6.Response.deserialize(data)
  end

  def deserialize(7, data) do
    V7.Response.deserialize(data)
  end

  def deserialize(8, data) do
    V8.Response.deserialize(data)
  end

  def deserialize(9, data) do
    V9.Response.deserialize(data)
  end

  (
    @typedoc "Union type for all request structs for this API"
    @type request_t ::
            Kayrock.Metadata.V9.Request.t()
            | Kayrock.Metadata.V8.Request.t()
            | Kayrock.Metadata.V7.Request.t()
            | Kayrock.Metadata.V6.Request.t()
            | Kayrock.Metadata.V5.Request.t()
            | Kayrock.Metadata.V4.Request.t()
            | Kayrock.Metadata.V3.Request.t()
            | Kayrock.Metadata.V2.Request.t()
            | Kayrock.Metadata.V1.Request.t()
            | Kayrock.Metadata.V0.Request.t()
  )

  (
    @typedoc "Union type for all response structs for this API"
    @type response_t ::
            Kayrock.Metadata.V9.Response.t()
            | Kayrock.Metadata.V8.Response.t()
            | Kayrock.Metadata.V7.Response.t()
            | Kayrock.Metadata.V6.Response.t()
            | Kayrock.Metadata.V5.Response.t()
            | Kayrock.Metadata.V4.Response.t()
            | Kayrock.Metadata.V3.Response.t()
            | Kayrock.Metadata.V2.Response.t()
            | Kayrock.Metadata.V1.Response.t()
            | Kayrock.Metadata.V0.Response.t()
  )

  (
    @doc "Returns the minimum version of this API supported by Kayrock (#{@vmin})"
    @spec min_vsn :: integer
    def min_vsn do
      0
    end
  )

  (
    @doc "Returns the maximum version of this API supported by Kayrock (#{@vmax})"
    @spec max_vsn :: integer
    def max_vsn do
      9
    end
  )
end
